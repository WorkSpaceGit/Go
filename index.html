<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Ґо</title>

  <!-- Фавіконка SVG -->
  <link id="favlink" rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <circle cx="32" cy="32" r="28" fill="black"/>
    <circle cx="32" cy="32" r="20" fill="none" stroke="yellow" stroke-width="4"/>
  </svg>'>

  <!-- PWA -->
  <meta name="theme-color" content="#dab357">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Ґо">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link id="manifest-link" rel="manifest" href="#">
  <link id="apple-touch" rel="apple-touch-icon" href="#">

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #181a1b;
      color: #eee;
      font-family: 'Segoe UI', Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 0;
    }
    #board-selector {
      display: flex;
      gap: 0.8em;
      margin: 1em 0 0.5em 0;
    }
    #board-selector button {
      background: #333;
      color: #eee;
      border: none;
      border-radius: 0.5em;
      padding: 0.45em 0.9em;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s;
      outline: none;
    }
    #board-selector button.active { background: #555; }
    #go-container {
      width: 87vw;
      max-width: 87vmin;
      aspect-ratio: 1/1;
      background: #dab357;
      border-radius: 1.2em;
      box-shadow: 0 0 16px #000a;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0.5em 0 1em 0;
      position: relative;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #go-board {
      width: 100%;
      height: 100%;
      display: block;
      background: #dab357;
      border-radius: 1em;
    }
    #info {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      text-align: center;
      min-height: 1.5em;
      letter-spacing: 0.02em;
    }
    #controls {
      display: flex;
      gap: 0.6em;
      justify-content: center;
      margin: 5.2em 0 1em 0;
      flex-wrap: wrap;
    }
    button {
      background: #333;
      color: #eee;
      border: none;
      border-radius: 0.5em;
      padding: 0.45em 0.9em;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.2s;
      outline: none;
    }
    button:active { background: #444; }
    .muted { opacity: 0.86; }
    @media (max-width: 600px) {
      #board-selector button { font-size: 0.95em; padding: 0.45em 0.7em; }
      #go-container { max-width: 99vw; }
    }
    #install-note {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 14px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 13px;
      display: none;
      z-index: 999;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="board-selector">
    <button data-size="9" class="active" aria-pressed="true">9×9</button>
    <button data-size="13" aria-pressed="false">13×13</button>
    <button data-size="19" aria-pressed="false">19×19</button>
  </div>

  <div id="go-container">
    <canvas id="go-board" role="img" aria-label="Дошка гри Ґо"></canvas>
  </div>

  <div id="info" aria-live="polite"></div>

  <div id="controls">
    <button id="pass-btn">Пас</button>
    <button id="toggle-mark-btn" style="display:none">Маркер: Чорні</button>
    <button id="final-count-btn" style="display:none">Фінальний підрахунок</button>
    <button id="clear-marks-btn" style="display:none">Очистити мітки</button>
    <button id="reset-btn">Нова гра</button>
  </div>

<script>
/* ================== Константи ================== */
let SIZE = 9;
const EMPTY = 0, BLACK = 1, WHITE = 2;
const STONE_COLORS = {1: "#222", 2: "#eee"};
const BOARD_COLOR = "#dab357";
const LINE_COLOR = "#444";
const LAST_MOVE_COLOR = "#f5c242";
const STAR_COLOR = "#444";
const STAR_PATTERNS = {
  9: [[2,2],[2,6],[6,2],[6,6],[4,4]],
  13: [[3,3],[3,9],[9,3],[9,9],[6,6]],
  19: [[3,3],[3,9],[3,15],[9,3],[9,9],[9,15],[15,3],[15,9],[15,15]]
};
const LETTERS_ALL = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

// DOM
const canvas = document.getElementById('go-board');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const passBtn = document.getElementById('pass-btn');
const resetBtn = document.getElementById('reset-btn');
const toggleMarkBtn = document.getElementById('toggle-mark-btn');
const finalCountBtn = document.getElementById('final-count-btn');
const clearMarksBtn = document.getElementById('clear-marks-btn');
const container = document.getElementById('go-container');

// Ігровий стан
let board, turn, ko, captures, history, passCount, gameOver, lastMove, territoryMap;
let markingMode, territoryMarks, markActive;

// Кеш
let pad = 0, cell = 0;
let coordsX = [], coordsY = [];

// Offscreen фон
const backgroundCanvas = document.createElement('canvas');
const backgroundCtx = backgroundCanvas.getContext('2d', { alpha: false });
/* ================== Ініціалізація ================== */
document.querySelectorAll('#board-selector button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#board-selector button').forEach(b => {
      b.classList.remove('active');
      b.setAttribute('aria-pressed', 'false');
    });
    btn.classList.add('active');
    btn.setAttribute('aria-pressed', 'true');
    SIZE = parseInt(btn.dataset.size, 10);
    init();
  });
});

function init() {
  board = Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
  turn = BLACK; ko = null;
  captures = {1:0, 2:0}; history = [];
  passCount = 0; gameOver = false;
  lastMove = null; territoryMap = null;
  markingMode = false;
  territoryMarks = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
  markActive = BLACK;

  toggleMarkBtn.style.display = 'none';
  finalCountBtn.style.display = 'none';
  clearMarksBtn.style.display = 'none';
  passBtn.style.display = 'inline-block';

  resizeCanvas();
  updateInfo();
}

/* ================== Canvas resize ================== */
let resizeTimer = null;
function resizeCanvas() {
  if (resizeTimer) clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(100, Math.floor(rect.width * dpr));
    canvas.height = Math.max(100, Math.floor(rect.height * dpr));
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    pad = canvas.width * 0.06;
    cell = (canvas.width - 2*pad) / (SIZE - 1);
    coordsX = Array.from({length: SIZE}, (_, i) => pad + i*cell);
    coordsY = Array.from({length: SIZE}, (_, i) => pad + i*cell);

    // Підготовка фонового canvas
    backgroundCanvas.width = canvas.width;
    backgroundCanvas.height = canvas.height;
    drawStaticBoard();

    draw();
  }, 120);
}
window.addEventListener('resize', resizeCanvas);

/* ================== Малювання ================== */
function drawStaticBoard() {
  backgroundCtx.fillStyle = BOARD_COLOR;
  backgroundCtx.fillRect(0,0,backgroundCanvas.width,backgroundCanvas.height);
  backgroundCtx.strokeStyle = LINE_COLOR;
  backgroundCtx.lineWidth = Math.max(1, cell * 0.035);
  for (let i=0;i<SIZE;i++) {
    backgroundCtx.beginPath();
    backgroundCtx.moveTo(coordsX[i], pad);
    backgroundCtx.lineTo(coordsX[i], backgroundCanvas.height - pad);
    backgroundCtx.stroke();
    backgroundCtx.beginPath();
    backgroundCtx.moveTo(pad, coordsY[i]);
    backgroundCtx.lineTo(backgroundCanvas.width - pad, coordsY[i]);
    backgroundCtx.stroke();
  }
  const LETTERS = LETTERS_ALL.slice(0, SIZE);
  backgroundCtx.fillStyle = "#444";
  backgroundCtx.font = `${cell*0.2}px Segoe UI, sans-serif`;
  backgroundCtx.textAlign="center"; backgroundCtx.textBaseline="middle";
  for (let i=0;i<SIZE;i++) {
    backgroundCtx.fillText(LETTERS[i], coordsX[i], pad*0.5);
    backgroundCtx.fillText(LETTERS[i], coordsX[i], backgroundCanvas.height - pad*0.5);
    backgroundCtx.fillText(SIZE - i, pad*0.5, coordsY[i]);
    backgroundCtx.fillText(SIZE - i, backgroundCanvas.width - pad*0.5, coordsY[i]);
  }
  backgroundCtx.fillStyle = STAR_COLOR;
  for (const [sx,sy] of (STAR_PATTERNS[SIZE]||[])) {
    if (sx>=0 && sx<SIZE && sy>=0 && sy<SIZE) {
      backgroundCtx.beginPath();
      backgroundCtx.arc(coordsX[sx], coordsY[sy], cell*0.13, 0, 2*Math.PI);
      backgroundCtx.fill();
    }
  }
}

function draw() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(backgroundCanvas,0,0);
  drawDynamicElements();
}

function drawDynamicElements() {
  for (let y=0;y<SIZE;y++) {
    for (let x=0;x<SIZE;x++) {
      if (board[y][x] !== EMPTY) {
        drawStone(ctx, coordsX[x], coordsY[y], cell*0.45, board[y][x]);
      }
    }
  }
  if (markingMode) {
    for (let y=0;y<SIZE;y++) {
      for (let x=0;x<SIZE;x++) {
        if (board[y][x]===EMPTY && territoryMarks[y][x]) {
          ctx.save();
          ctx.globalAlpha = 0.45;
          ctx.fillStyle = STONE_COLORS[territoryMarks[y][x]];
          ctx.beginPath();
          ctx.arc(coordsX[x], coordsY[y], cell*0.36, 0, 2*Math.PI);
          ctx.fill();
          ctx.restore();
        }
      }
    }
  }
  if (gameOver && territoryMap) {
    for (let y=0;y<SIZE;y++) {
      for (let x=0;x<SIZE;x++) {
        if (board[y][x]===EMPTY && territoryMap[y] && territoryMap[y][x]) {
          const owner=territoryMap[y][x];
          ctx.save();
          ctx.beginPath();
          ctx.arc(coordsX[x], coordsY[y], cell*0.18, 0, 2*Math.PI);
          ctx.fillStyle=STONE_COLORS[owner];
          ctx.fill(); ctx.restore();
        }
      }
    }
  }
  if (lastMove) {
    const [lx,ly] = lastMove;
    ctx.save();
    ctx.strokeStyle = LAST_MOVE_COLOR;
    ctx.lineWidth = cell*0.09;
    ctx.beginPath();
    ctx.arc(coordsX[lx], coordsY[ly], cell*0.22, 0, 2*Math.PI);
    ctx.stroke();
    ctx.restore();
  }
}

function drawStone(ctxLocal, cx, cy, r, color) {
  ctxLocal.beginPath();
  ctxLocal.arc(cx, cy, r, 0, 2*Math.PI);
  ctxLocal.fillStyle = STONE_COLORS[color];
  ctxLocal.fill();
}

/* ================== Події користувача ================== */
canvas.addEventListener('pointerdown', handleInput);

function handleInput(e) {
  if (gameOver && !markingMode) return;

  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  let clientX = e.clientX, clientY = e.clientY;
  if (e.pointerType === "touch" && e.touches && e.touches[0]) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  }

  const xPx = (clientX - rect.left) * dpr;
  const yPx = (clientY - rect.top) * dpr;

  const rawX = (xPx - pad) / cell;
  const rawY = (yPx - pad) / cell;

  let x = Math.round(rawX);
  let y = Math.round(rawY);

  if (x < 0) x = 0; if (x >= SIZE) x = SIZE-1;
  if (y < 0) y = 0; if (y >= SIZE) y = SIZE-1;

  const dx = xPx - coordsX[x];
  const dy = yPx - coordsY[y];
  const maxAcceptDist = cell * 0.6;
  if (dx*dx + dy*dy > maxAcceptDist*maxAcceptDist) return;

  requestAnimationFrame(()=>{
    if (markingMode) {
      if (board[y][x]!==EMPTY) return;
      territoryMarks[y][x] = (territoryMarks[y][x]===markActive)?0:markActive;
      draw(); updateInfo();
    } else {
      if (board[y][x]!==EMPTY) return;
      playMove(x,y);
    }
  });
}
/* ================== Ходи ================== */
function playMove(x,y) {
  let testBoard = board.map(r=>r.slice());
  testBoard[y][x] = turn;
  let captured = removeCaptured(testBoard, 3-turn);
  let selfCapture = !hasLiberties(testBoard,x,y,turn,new Set(),[]);
  if (selfCapture && captured.length===0) return;
  const newHash = hashBoard(testBoard);
  if (ko && ko===newHash) return;

  board = testBoard;
  lastMove=[x,y];
  captures[turn]+=captured.length;
  history.push({boardHash:hashBoard(board), move:[x,y], turn:turn});
  if (captured.length===1) {
    ko = history.length? history[history.length-1].boardHash:null;
  } else ko=null;
  turn=3-turn; passCount=0;
  draw(); updateInfo();
}

/* ================== Захоплення ================== */
function removeCaptured(bd,color) {
  let removed=[]; let visited=new Set();
  for (let y=0;y<SIZE;y++) {
    for (let x=0;x<SIZE;x++) {
      if (bd[y][x]===color && !visited.has(`${x},${y}`)) {
        let group=[];
        if (!hasLiberties(bd,x,y,color,new Set(),group)) {
          for (const [gx,gy] of group) {
            bd[gy][gx]=EMPTY; removed.push([gx,gy]);
          }
        }
        for (const [gx,gy] of group) visited.add(`${gx},${gy}`);
      }
    }
  }
  return removed;
}

function hasLiberties(bd,x,y,color,visited,group) {
  const key=`${x},${y}`;
  if (visited.has(key)) return false;
  visited.add(key);
  if (group) group.push([x,y]);
  const liberties=new Set();
  for (const [dx,dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
    const nx=x+dx, ny=y+dy;
    if (nx<0||nx>=SIZE||ny<0||ny>=SIZE) continue;
    if (bd[ny][nx]===EMPTY) liberties.add(`${nx},${ny}`);
    if (bd[ny][nx]===color && !visited.has(`${nx},${ny}`)) {
      if (hasLiberties(bd,nx,ny,color,visited,group)) return true;
    }
  }
  return liberties.size>0;
}

/* ================== Територія ================== */
function computeAutoTerritory() {
  let territory=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  let visited=new Set();
  for (let y=0;y<SIZE;y++) {
    for (let x=0;x<SIZE;x++) {
      if (board[y][x]===EMPTY && !visited.has(`${x},${y}`)) {
        let area=[]; let owner=territoryOwner(x,y,area);
        for (const [ax,ay] of area) {
          visited.add(`${ax},${ay}`);
          territory[ay][ax]=owner?owner:0;
        }
      }
    }
  }
  return territory;
}
function territoryOwner(x,y,area) {
  let queue=[[x,y]]; let owners=new Set(); let visited=new Set();
  while(queue.length) {
    let [cx,cy]=queue.pop();
    let key=`${cx},${cy}`; if (visited.has(key)) continue;
    visited.add(key); area.push([cx,cy]);
    for (const [dx,dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
      let nx=cx+dx, ny=cy+dy;
      if (nx<0||nx>=SIZE||ny<0||ny>=SIZE) continue;
      if (board[ny][nx]===EMPTY && !visited.has(`${nx},${ny}`)) queue.push([nx,ny]);
      else if (board[ny][nx]!==EMPTY) owners.add(board[ny][nx]);
    }
  }
  return owners.size===1? [...owners][0]:null;
}

/* ================== Хеш дошки ================== */
function hashBoard(bd){ return bd.map(r=>r.join("")).join("|"); }

/* ================== Підрахунок ================== */
function finalizeScoring() {
  const auto=computeAutoTerritory();
  let finalMap=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  for (let y=0;y<SIZE;y++) {
    for (let x=0;x<SIZE;x++) {
      if (board[y][x]===EMPTY) {
        if (auto[y][x]!==0) finalMap[y][x]=auto[y][x];
        else if (territoryMarks[y][x]!==0) finalMap[y][x]=territoryMarks[y][x];
      }
    }
  }
  let territory={1:0,2:0};
  for (let y=0;y<SIZE;y++) {
    for (let x=0;x<SIZE;x++) {
      if (board[y][x]===EMPTY && finalMap[y][x]) territory[finalMap[y][x]]++;
    }
  }
  const KOMI=6.5;
  let blackScore=territory[1]+captures[1];
  let whiteScore=territory[2]+captures[2]+KOMI;
  let msg=`<div style="line-height:1.4; text-align:center;">`+
          `<b>Результат:</b><br>`+
          `Чорні — ${territory[1]} тер, ${captures[1]} захоплено, <b>${blackScore}</b><br>`+
          `Білі — ${territory[2]} тер, ${captures[2]} захоплено, комі ${KOMI}, <b>${whiteScore}</b><br>`;
  if (blackScore>whiteScore) msg+=`<b>Перемогли Чорні!</b>`;
  else if (blackScore<whiteScore) msg+=`<b>Перемогли Білі!</b>`;
  else msg+=`<b>Нічия!</b>`;
  msg+=`</div>`;
  territoryMap=finalMap; gameOver=true; markingMode=false;
  toggleMarkBtn.style.display='none'; finalCountBtn.style.display='none';
  clearMarksBtn.style.display='none'; passBtn.style.display='none';
  draw(); showInfo(msg);
}

/* ================== Info ================== */
function updateInfo() {
  if (gameOver) return;
  if (markingMode) {
    const auto=computeAutoTerritory();
    let preview=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) {
      if (board[y][x]===EMPTY) {
        if (auto[y][x]!==0) preview[y][x]=auto[y][x];
        else if (territoryMarks[y][x]!==0) preview[y][x]=territoryMarks[y][x];
      }
    }
    let territory={1:0,2:0};
    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) {
      if (board[y][x]===EMPTY && preview[y][x]) territory[preview[y][x]]++;
    }
    const KOMI=6.5;
    let blackScore=territory[1]+captures[1];
    let whiteScore=territory[2]+captures[2]+KOMI;
    const who=markActive===BLACK?'Чорні':'Білі';
    info.innerHTML=`Режим маркування: <b>${who}</b><br>`+
      `Попередній рахунок → ⚫ ${blackScore.toFixed(1)} : ⚪ ${whiteScore.toFixed(1)}`;
    return;
  }
  info.innerHTML=(turn===BLACK?"Хід Чорних":"Хід Білих")+
    ` | Захоплено — ⚫ ${captures[1]}  ⚪ ${captures[2]} | Для завершення: двічі пас.`;
}
function showInfo(msg){ info.innerHTML=msg; }

/* ================== Кнопки ================== */
passBtn.onclick=function(){
  if (gameOver) return;
  passCount++;
  if (passCount>=2) {
    markingMode=true; markActive=BLACK;
    territoryMarks=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
    toggleMarkBtn.style.display='inline-block';
    finalCountBtn.style.display='inline-block';
    clearMarksBtn.style.display='inline-block';
    passBtn.style.display='none';
    draw(); updateInfo();
  } else {
    turn=3-turn; lastMove=null; draw(); updateInfo();
  }
};
toggleMarkBtn.onclick=function(){
  markActive=(markActive===BLACK)?WHITE:BLACK;
  toggleMarkBtn.innerText=markActive===BLACK?'Маркер: Чорні':'Маркер: Білі';
  updateInfo();
};
clearMarksBtn.onclick=function(){ 
  territoryMarks=Array.from({length:SIZE},()=>Array(SIZE).fill(0)); 
  draw(); updateInfo(); 
};
finalCountBtn.onclick=function(){ finalizeScoring(); };
resetBtn.onclick=function(){ init(); };
init();

/* ================== PWA: manifest, icons, service worker ================== */
(async function preparePWA() {
  try {
    const favLink=document.getElementById('favlink');
    const svgURL=favLink.href;

    function svgToPngDataUrl(svgUrl,size) {
      return new Promise((resolve,reject)=>{
        const img=new Image(); img.crossOrigin='anonymous';
        img.onload=function() {
          const c=document.createElement('canvas'); c.width=size; c.height=size;
          const cx=c.getContext('2d');
          cx.fillStyle='#00000000'; cx.fillRect(0,0,size,size);
          cx.drawImage(img,0,0,size,size);
          try { resolve(c.toDataURL('image/png')); } catch(err){ reject(err); }
        };
        img.onerror=(e)=>reject(e||new Error('Image load error'));
        img.src=svgUrl;
      });
    }

    const iconSizes=[192,512]; const manifestIcons=[];
    for (const s of iconSizes) {
      try {
        const png=await svgToPngDataUrl(svgURL,s);
        manifestIcons.push({src:png,sizes:`${s}x${s}`,type:'image/png',purpose:'any'});
      } catch(e){ console.warn('Не вдалося створити іконку',s,e); }
    }
    try {
      const applePng=await svgToPngDataUrl(svgURL,180);
      document.getElementById('apple-touch').href=applePng;
    } catch(e){ console.warn('apple icon error',e); }

    const startUrl=location.pathname+location.search;
    const manifest={
      name:"Ґо", short_name:"Ґо",
      description:"Гра Ґо — оптимізована PWA",
      start_url:startUrl, scope:"/",
      display:"standalone",
      background_color:"#181a1b", theme_color:"#dab357",
      icons:manifestIcons
    };
    const manifestBlob=new Blob([JSON.stringify(manifest)],{type:'application/json'});
    const manifestURL=URL.createObjectURL(manifestBlob);
    document.getElementById('manifest-link').href=manifestURL;

    const isIOS=/iphone|ipad|ipod/i.test(navigator.userAgent);
    if (isIOS) document.getElementById('install-note').style.display='block';

    if ('serviceWorker' in navigator) {
      const swCode=`
        const CACHE_NAME='paw-go-cache-v1';
        const OFFLINE_FALLBACK_HTML='/';
        self.addEventListener('install',e=>{
          self.skipWaiting();
          e.waitUntil((async()=>{
            const cache=await caches.open(CACHE_NAME);
            try {
              const req=new Request(location.pathname,{cache:'no-cache'});
              const resp=await fetch(req);
              if (resp&&resp.ok) await cache.put(req,resp.clone());
            }catch(err){}
          })());
        });
        self.addEventListener('activate',e=>{
          e.waitUntil((async()=>{
            const keys=await caches.keys();
            await Promise.all(keys.map(k=>{if(k!==CACHE_NAME) return caches.delete(k);}));
            self.clients.claim();
          })());
        });
        self.addEventListener('fetch',e=>{
          const req=e.request;
          if (req.method!=='GET') return;
          e.respondWith((async()=>{
            const cache=await caches.open(CACHE_NAME);
            const cached=await cache.match(req);
            if (cached) return cached;
            try {
              const networkResp=await fetch(req);
              if (networkResp&&networkResp.ok&&req.url.startsWith(self.location.origin)) {
                cache.put(req,networkResp.clone()).catch(()=>{});
              }
              return networkResp;
            }catch(err){
              const fallback=await cache.match(OFFLINE_FALLBACK_HTML);
              return fallback||new Response('Offline',{status:503});
            }
          })());
        });
      `;
      const swBlob=new Blob([swCode],{type:'application/javascript'});
      const swURL=URL.createObjectURL(swBlob);
      try {
        const reg=await navigator.serviceWorker.register(swURL,{scope:'./'});
        console.log('SW registered',swURL,reg);
      } catch(err){ console.warn('SW registration failed:',err); }
    }
  } catch(err){ console.error('preparePWA error',err); }
})();
</script>
</body>
</html>
